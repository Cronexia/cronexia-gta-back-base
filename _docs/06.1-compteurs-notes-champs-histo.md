# Compteurs, notes relatives aux ğŸ“œ champs historisÃ©s

Histoire de garder une trace des rÃ©flexions & des algos.

Jira [POC-116](https://cronexia.atlassian.net/browse/POC-116)

---

## ğŸš€ğŸ“œ POC-116 > Gestion des valeurs historisÃ©es (Resource & Schedule)

### ğŸ“ğŸ§ âš¡ï¸ Algos & optimisations

ğŸ§  Normaliser algo pour tout

- RÃ©cupÃ©ration des donnÃ©es historisÃ©es ( resource & pÃ©riode )
  - Partial query & rÃ©cupÃ©ration
    - âœ…âš¡ï¸ 1 seule requÃªte pour l'ensemble des resources & rÃ©partition ?
      - Plus chaud pour la RAM mais plus optimisÃ© pour la BDD
    - âŒğŸŒ ou une requÃªte par resource ?
      - Plus chaud pour la BDD mais plus optimisÃ© pour la RAM
  - affecter a la resource concernÃ©e
  - â™»ï¸ pour chaque date
    - Si nouvelle valeur > affecter aux variables
    - Sinon rÃ©utiliser
  - â™»ï¸ Effectuer les steps
  - Profit

---

#### ğŸ“ğŸ§  ResourceNbrVal > PrÃ©parer

On commence par celle la car:

- C'est la plus pertinente vis Ã  vis de ResultFlt
- Moins de relations qu'avec Enum
- Permettra d'Ã©prouver l'algo & corriger avant de le traiter en masse

Champs existant dans la BDD : `employmentRatePercent`

Compteurs > comment associer les donnÃ©es ? Params ?

```js
model CtParam {
  // ğŸ“ğŸ”§ Ressources > Champs dynamiques
  //      ResourceField
  //        ResourceBolVal
  //        ResourceDatVal
  //        ResourceNbrVal
  //        ResourceStrVal
  //        ResourceEnum
  //          ResourceEnumNbrVal
  //          ResourceEnumStrVal
  resourceField   ResourceField? @relation(fields: [resourceFieldId], references: [idResourceField])
  resourceFieldId String?        @unique @db.Uuid
}
```

Hm mwÃ© on peut thÃ©oriquement passer par ResourceField pour aller vers ResourceNbrVal qui contient la valeur.

En gros on "demande" le champ de ResourceFields > cela nous permet de rÃ©cupÃ©rer sa valeur, affectÃ©e Ã  la Resource.

Structure & relations de ResourceFields ?

```js
// * ğŸ“ğŸ”§ Ressources > Champs dynamiques
model ResourceField {
  name String @unique

  type resourceFieldTypeEnum // Boolean, Datetime, Number, String, EnumNumber, EnumString, TodoOther

  // ğŸ”— * Relations

  // ğŸ“ğŸ—ƒï¸ Type enforced values
  resourceBolVals ResourceBolVal[]
  resourceDatVals ResourceDatVal[]
  resourceNbrVals ResourceNbrVal[]
  resourceStrVals ResourceStrVal[]

  // ğŸ“ğŸ“š ENUMs fields and types
  resourceEnum   ResourceEnum? @relation(fields: [resourceEnumId], references: [idResourceEnum])
  resourceEnumId String?       @db.Uuid

  parameter CtParam?
}

// ---
// ---
// ---

// * ğŸ“ğŸ—ƒï¸ğŸ”¢ Ressources > Stockage des valeurs typÃ©es Number
model ResourceNbrVal {
  // ğŸ‘Œ Type enforcement
  value Int?

  // ğŸ“œ History
  effectDate DateTime @db.Date

  // ---

  // ğŸ”— * Relations

  // ğŸ“ Which Resource is this value related to ?
  resource   Resource? @relation(fields: [resourceId], references: [idResource])
  resourceId String?   @db.Uuid

  // ğŸ“ğŸ”§ Which ResourceField is this value related to ?
  resourceField   ResourceField? @relation(fields: [resourceFieldId], references: [idResourceField])
  resourceFieldId String?        @db.Uuid
}
```

âŒ ci dessous: non. Pas de nested group by dans Prisma (pas encore implÃ©mentÃ©)

            du coup le select de prisma ressemblera Ã  Ã§a :

            - counter
              - step
                - whatever / tout
                  - param
                    - ResourceField findUnique (`WHERE` name ou id)
                      - resourceNbrVals  findManyHisto (`WHERE` resourceId)
                        - ğŸš¨ findMany > pour l'historique, plusieurs valeurs via effectDate
                        - ğŸš¨ğŸš¨ Histo > Besoin de 2 requÃªtes
                          - PremiÃ¨re valeur avant ou Ã©gale Ã  la date de dÃ©but de pÃ©riode
                          - Autres valeurs (nulles ou non) > (strict) Ã  la date de dÃ©but de pÃ©riode et <= Ã  la date de fin de pÃ©riode

            ğŸš¨ğŸš¨ Besoin des infos des paramÃ¨tres avant de pouvoir les rÃ©cupÃ©rer

            - Besoin d'une requÃªte prÃ©liminaire compteur pour rÃ©cupÃ©rer tous les paramÃ¨tres de types particuliers ; Ã  minima leurs ids
              - afin de pouvoir rÃ©cupÃ©rer les donnÃ©es
              - ğŸ§ ğŸ§ ğŸ§  hmmm pas forcÃ©ment en fait, cf. requÃªte ci-dessus
                - ğŸ§  On peut peut Ãªtre les rÃ©cupÃ©rer directement depuis le compteur ?
                  - Si c'est dÃ©jÃ  connectÃ© dans les seeds
                  - Go checker la requÃªte

            ğŸ§ ğŸš¨ğŸ’¾ğŸ’¾ğŸ’¾ Il manque peut Ãªtre des relations : ğŸ’¾ğŸ’¾ğŸ’¾ ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”® EDIT DU FUTUR: en effet, on doit avoir les resources correspondantes aux valeurs

            - Step <> champs persos > un champ perso peut Ãªtre affectÃ© Ã  une variable
            - Result <> champs persos > On peut renvoyer un champ perso
            - â¬†ï¸ ou pour les deux > virer la majoritÃ© des relations & associer Ã  Params

            BREF

---

RequÃªte partielle SELECT pour les Params (utilisÃ©e dans les compteurs)

ğŸ” SÃ©lection des valeurs des Resources du compteur via > ~ where: resourceId: in: [000059, 000060, 000061, etc.]

```js
// * ğŸ¤ğŸ”âš™ï¸ Parameter Partial Query
export const partialQuerySelectParam = {
  select: {
    // * âš™ï¸ Params
    idParam: true, // ğŸ‘·

    // [...]
    constant: ~true,
    variable: ~true,
    function: ~true,

    // ! On pourrait donc rajouter
    // ğŸ“ğŸ”§ Ressources > Champs dynamiques, ğŸ“œ historisÃ©es
    resourceField: {
      select: {
        name: true,
        type: true, // Boolean, Datetime, Number, String, EnumNumber, EnumString, TodoOther

        // resourceBolVals ResourceBolVal[]
        // resourceDatVals ResourceDatVal[]
        // resourceNbrVals ResourceNbrVal[]
        // resourceStrVals ResourceStrVal[]
        // resourceEnum   ResourceEnum

        resourceNbrVals: {
          select: {
            idResourceNbrVal: true,
            value: true,
            effectDate: true, // ğŸ“œ

            resourceId: true, // âš—ï¸ permettrait de filtrer
          },
        },
        // MÃªme bail pour resourceBolVals, resourceDatVals, resourceStrVals

        resourceEnum: { // * Quelle variable ?
          select: {
            name: true,
            type: true, // resourceEnumTypeEnum // Number, String

            resourceEnumVals: { // * AssociÃ©e Ã  quelle Resource, Ã  quelle date ?
              select: {
                effectDate: true, // ğŸ“œ
                resourceId: true, // âš—ï¸ permettrait de filtrer

                // * Quelles valeurs ?
                resourceEnumNbrVal: {
                  select: {
                    value: true,
                  },
                },
                resourceEnumStrVal: {
                  select: {
                    value: true,
                  },
                },
              },
            },
          },
        },
      },
    },

    // ---
    // ---
    // ---

    // âŒš Valeurs de **RÃ©fÃ©rence** ğŸ“œ historisÃ©es
    // referenceValue String? @default("TODO")
    //      ScheduleReference
    //          ScheduleBolVal
    //          ScheduleNbrVal
    //          âŒ ScheduleEnum             // Hors POC
    //            âŒ ScheduleEnumStrVal     // Mais au pire mÃªme bail que resourceEnum

    // IMAGINONS QUE CELA SOIT EN PLACE
    referenceValue: {
      select: {
        code: true,
        fieldname: true,
        type: true, // scheduleReferenceTypeEnum // Boolean, Number

        // âŒšğŸ—ƒï¸ Type enforced values
        // scheduleBolVals ScheduleBolVal[]
        // scheduleNbrVals ScheduleNbrVal[]

        scheduleBolVals: {
          select: {
            value: true,
            effectDate: true, // ğŸ“œ
          },
        },

        scheduleNbrVals: {
          select: {
            value: true,
            effectDate: true, // ğŸ“œ
          },
        },

        ScheduleEnum: {
          select: {
            name: true,
            type: true, // scheduleEnumTypeEnum // String

            // âŒšğŸ“šğŸ‘Œ ENUMs type enforced values
            // scheduleEnumStrVals ScheduleEnumStrVal[]
            scheduleEnumStrVals: {
              select: {
                value: true,
                effectDate: true, // ğŸ“œ
              },
            },
          },
        },
      },
    },
  },
};
```

ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”® EDIT DU FUTUR: Yeah cela ramÃ¨ne l'intÃ©gralitÃ© des valeurs pour l'intÃ©gralitÃ© des resources, mais non groupÃ©es
ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”® ğŸ“Œ A voir si possibilitÃ© de group by dans une requÃªte nestÃ©e mais de mÃ©moire non (pas sans rawQuery)
ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®ğŸ”®    âŒ Pas encore implÃ©mentÃ©

ğŸ¤®ğŸ§ ğŸ¤®

- ğŸ‘· Une seule requÃªte pour opti, mais par contre dans le retour cela risque d'Ãªtre le bordel Ã  gÃ©rer Ã  la mano..
  - ~~ğŸ’© Et encore, faible intÃ©rÃªt si on injecte les liste d'ids de resources.~~
  - âš—ï¸âš—ï¸âš—ï¸ L'intÃ©rÃªt est de cibler les ParamÃ¨tres (champs persos) rattachÃ©s au compteur
    - âš¡ï¸ On passe la liste d'ids des resources en mÃªme temps SSI on souhaite rÃ©cupÃ©rer les valeurs des params en mÃªme temps
      - âš¡ï¸ Tant qu'on y est
- ---
- ğŸ§ ğŸ‘· Vaudrait ptet mieux deux requÃªtes, surtout s'il faut extraire afin de gÃ©rer l'historique
  - ~group by resource ou kekchose
  - âŒ RequÃªte prÃ©liminaire similaire mais juste vÃ©rifier si des Params sont != de null.. j'sais pas
    - ğŸ”®âœ… Non, rÃ©cupÃ©ration lors de la rÃ©cupÃ©ration du compteur, mais sans les valeurs

âŒ RÃ©cupÃ©ration du rattachement au compteur ? Si on remonte dans l'autre sens

```js
model ResourceField {
  parameter       CtParam?
    // la RF peut Ãªtre utilisÃ©e dans l'un des deux paramÃ¨tres Ã  tester d'une Condition
    //    ~ SI ( employementRatePc > 90 )
    paramLeft       CtCondition
    paramRight      CtCondition

    // la RF peut Ãªtre utilisÃ©e dans l'un des calculs
    //    ~ employementRatePc / 10
    param           CtCalc
    
    // la RF peut Ãªtre utilisÃ©e dans l'un des deux paramÃ¨tres d'une fonction
    //    ~ MAX ( employementRatePc, 90 )
    paramFirstFn    CtFunction
    paramSecondFn   CtFunction
    
    // la RF peut Ãªtre utilisÃ©e afin d'Ãªtre affectÃ©e Ã  une variable
    // A confirmer
    variable   CtStep ?
}
```

- ğŸŒ Mais en dehors de step pour remonter chacun au compteur c'est relou.
- âŒ On pourrait rajouter une relation Param <> Compteur may bon idem pas hyper intuitif
  - & il y en a dÃ©jÃ  une (un Compteur peut Ãªtre un paramÃ¨tre)
    - MÃªme si on peut en avoir 2 en les nommants

pwahÂ²Â²Â²

---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---


---
---
---
---
---
---
---
---
---

## ğŸ§  Reprise Ã  tÃªte reposÃ©e

- NOTE: ğŸš¨ğŸš¨ Histo > Besoin de 2 requÃªtes
  - PremiÃ¨re valeur avant ou Ã©gale Ã  la date de dÃ©but de pÃ©riode
  - Autres valeurs (nulles ou non) > (strict) Ã  la date de dÃ©but de pÃ©riode et <= Ã  la date de fin de pÃ©riode
  - ğŸ§ âš¡ï¸ Probablement possibilitÃ© de n'en faire qu'une seul requÃªte avec un `OR` + ordonner
    - ğŸ§ ğŸ§ ğŸ§  Permettrait d'avoir un ~select/where partiel rÃ©utilisable

---

ğŸ§  Bon afin que tout soit rÃ©utilisable & avec tous les parmamÃ¨tres, c'est quand mÃªme Ã¼ber compliquÃ©

Pour le moment en entrÃ©e on a

- resources (tableau de resourcesIds aprÃ¨s une requÃªte)
- pÃ©riode (tableau de dates, ordonnÃ©es)
- un compteur avec toutes ses Ã©tapes et ce qui s'en suit (objets imbriquÃ©s)

---

- En ~sortie (ou tout du moins afin de produire la sortie), il nous manque
  - des donnÃ©es *(si on prend ResourceNbrVal pour simplifier)* **associÃ©es**
    - Ã  ce **compteur**, et plus prÃ©cisÃ©ment Ã  ses paramÃ¨tres
      - ~= `je fais un calcul dont l'un des paramÃ¨tres est ResourceNbrVal`
    - Ã  chacune des **Resources**
      - ~= si 3 Resources, je rÃ©cupÃ¨re, groupÃ©es par Resources
        - l'ensemble des donnÃ©es correspondantes sur cette pÃ©riode

---

Boucles actuelles du compteur

// * â™»ï¸ğŸ“ For each Resource
  // * â™»ï¸ğŸ“… For each date of the period
    // * â™»ï¸ğŸ§®ğŸªœ For each Counter step

âš¡ï¸ En vue d'optimisation, DANS L'IDEAL, les donnÃ©es devraient

- DÃ©jÃ  Ãªtre accessibles depuis la premiÃ¨re boucle resource, uniquement les changements d'histo
- Stocker une "valeur en cours"
  - InitialisÃ©e avec la valeur de base
  - TestÃ©e pour mise Ã  jour Ã  chaque date

---
---
---
---
---
---
---
---
---
---

### ğŸŒğŸ‘€ DÃ©roulÃ© Ã  la mano, concrÃ¨tement ğŸŒğŸ‘€

- PO employmentRatePercent en base de donnÃ©es
  - 2023-12-01  > 100
  - 2024-04-03  > null
  - 2024-04-05  > 90

---

```js
// ğŸ“…ğŸ“… period : 2024-04-01 au 2024-04-07

// Le jeu de donnÃ©es des resources contient plus que les ids
//    Les donnÃ©es custom historisÃ©es pertinentes ont Ã©tÃ© rÃ©cupÃ©rÃ©es avant
const resources = [
  {
    PO: {
      employmentRatePercent: {
        // â¬†ï¸ ordonnÃ© par dates !
        2023-12-01: 100,
        2024-04-03: null,
        2024-04-05: 90,
      }
    }
  }
]

const ~datesSurLesquellesTourner = [
  2024-04-01,
  2024-04-02,
  2024-04-03,
  2024-04-04,
  2024-04-05,
  2024-04-06,
  2024-04-07,
]


// * â™»ï¸ğŸ“ For each Resource
{
  // PO

  // ~~const currentEmploymentRatePercent~~
  // Initialiser avec premiÃ¨re valeur Ã  date
  let currentCustomValues = {
    // * On renvoie la premiÃ¨re valeur du tableau, en la retirant dudit tableau
    employmentRatePercent = currentResource.employmentRatePercent.shift();

    ğŸ‘€ `employmentRatePercent = 100,`
  };

  // * â™»ï¸ğŸ“… For each date of the period
  {
    // â¬†ï¸ğŸ“œ Maj historique si besoin
    // * Si la date actuelle correspond Ã  celle d'un changement d'historique
    if (currentDate === currentResource.employmentRatePercent[0]) {
      // On maj la valeur en la supprimant du tableau
      employmentRatePercent = currentResource.employmentRatePercent.shift();
    }

    // * â™»ï¸ğŸ§®ğŸªœ For each Counter step
    {
      // Si variable kustom, on l'utilise
      // ! ğŸ’¥ Passage Ã  l'intÃ©rieur ? RÃ©fÃ©rences
      ğŸ§  Ptet le plus simple serait de les traiter comme les variables steps
      //      manageParam > case 'Variable' > getVariableValue(step.variableName, counterCode)

      Ce qui donnerait ~
      //      manageParam > case 'ResourceNbrVal' > get_ResourceNbrVal_Value(label, resourceId, counterCode)
    }

    ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€
    2024-04-01,
      ğŸ‘€ `employmentRatePercent = 100`
      Si 2024-04-01 === PO.employmentRatePercent.2024-04-03 // ğŸ“ŒâŒ false

      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(100);

    2024-04-02,
      ğŸ‘€ `employmentRatePercent = 100`
      Si 2024-04-02 === PO.employmentRatePercent.2024-04-03 // ğŸ“ŒâŒ false

      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(100);

    2024-04-03,
      ğŸ‘€ `employmentRatePercent = 100`
      Si 2024-04-03 === PO.employmentRatePercent.2024-04-03 // ğŸ“Œâœ… true

        // â¬†ï¸ğŸ“œ Maj historique
        ğŸ‘€ `employmentRatePercent = null`
      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(null);

    2024-04-04,
      ğŸ‘€ `employmentRatePercent = null`
      Si 2024-04-04 === PO.employmentRatePercent.2024-04-05 // ğŸ“ŒâŒ false

      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(null);

    2024-04-05,
      ğŸ‘€ `employmentRatePercent = null`
      Si 2024-04-05 === PO.employmentRatePercent.2024-04-05 // ğŸ“Œâœ… true

        // â¬†ï¸ğŸ“œ Maj historique
        ğŸ‘€ `employmentRatePercent = 90`
      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(90);

    2024-04-06,
      ğŸ‘€ `employmentRatePercent = 90`
      //                v tester pour PO.employmentRatePercent.length > 0
      Si 2024-04-06 === rieng // ğŸ“ŒâŒ false

      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(90);

    2024-04-07,
      ğŸ‘€ `employmentRatePercent = 90`
      Si 2024-04-07 === rieng // ğŸ“ŒâŒ false

      ğŸªœ For each Counter step > calculs, etc.
        calculsAvec(90);

    /ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€
  }
}
```

ğŸ§  Ca paraÃ®t Ã  la fois pas dÃ©connant, et faisable, pour le peu que les donnÃ©es soient bien la avant.

---
---
---
---
---
---
---
---

## â¬‡ï¸ RÃ©cupÃ©rer les donnÃ©es custom pertinente, de maniÃ¨re opti

Stop se disperser sur les diffÃ©rentes Ã©tapes.

MÃªme s'il est indispensable d'avoir le point de vue d'ensemble...

- En ~sortie (ou tout du moins afin de produire la sortie), il nous manque
  - des donnÃ©es *(si on prend ResourceNbrVal pour simplifier)* **associÃ©es**
    - Ã  ce **compteur**, et plus prÃ©cisÃ©ment Ã  ses paramÃ¨tres
      - ~= `je fais un calcul dont l'un des paramÃ¨tres est ResourceNbrVal`
    - Ã  chacune des **Resources**
      - ~= si 3 Resources, je rÃ©cupÃ¨re, groupÃ©es par Resources
        - l'ensemble des donnÃ©es correspondantes sur cette pÃ©riode

ğŸ‘€ğŸ‘€ğŸ‘€

ğŸ‘ŒğŸ“œ AFIN DE POUVOIR TOURNER CORRECTEMENT ğŸ‘ŒğŸ“œ

- Pour
  - CPT qui utilise ResourceNbrVal
  - Resources [max, po hom]
  - date[du 01/04 au 07/04]
- ---
- ---
- ---
- En ~~sortie~~ donnÃ©es resources je veux
  - Resources [
    - max // ğŸŒ± une seule valeur, dÃ©finie avant
      - employmentRatePercent
        - 01/04: 80
    - ---
    - po // ğŸŒ± une valeur dÃ©finie avant, puis null, puis autre valeur
      - employmentRatePercent
        - 01/04: 100
        - 03/04: null
        - 05/04: 90
    - ---
    - hom // ğŸŒ± une seule valeur, dÃ©finie en milieu de pÃ©riode
      - employmentRatePercent
        - 03/04: 85
  - ]

ok yeah good.

Maintenant comment obtenir Ã§a ? Revoir notes vendredi.

---

CtParam > entityType

// Constant, Variable, Function, Counter, ResourceField, EventDuration,
// EventQuantity, EventDurationAggregated, EventQuantityAggregated, ReferenceValue

- A voir si besoin de spÃ©cifier plus > ResourceField_ResourceNbrVal
  - gros switch des familles
- Ou si on teste Ã  chaque fois quelle valeur est nulle

RÃ©cupÃ©rer les infos necÃ©ssaires : â¬‡ï¸

- Kwa > ResourceField.name
  - ğŸ”— CtParam > resourceField
- Valeurs > ResourceField.resourceNbrVals.value<Int?>
  - ğŸ”— (CtParam >) resourceField > resourceNbrVals
  - ğŸ”—âš—ï¸ resourceNbrVals.resource

- ğŸ“ Note: le nom du champ n'est pas explicitement stockÃ© dans compteur > .. > params
  - C'est la relation param > ResourceFields qui permet de dÃ©terminer quel champs custom est associÃ© au param (via resourceFieldId)

---
---
---
---
---
---
---
---
---
---

ğŸ§ ğŸ”€ Bon j'ai le cerveau qui pÃ©dale dans la semoule mais je pense que cela vient du fait qu'il y a deux maniÃ¨res de faire intercheangeables

1. RequÃªte compteur > injection des id des resources lors de la rÃ©cupÃ©ration des paramÃ¨tres concernÃ©s
   1. On rÃ©cupÃ¨re les donnÃ©es historisÃ©es directement depuis le compteur
   2. Ce qui nous Ã©vite de faire le lien entre le compteur, et ses propres paramÃ¨tres
2. ---
3. RequÃªte resources
   1. Pas de soucis pour rÃ©cupÃ©rer les donnÃ©es liÃ©es
   2. Besoin de faire le lien compteur/params afin de savoir quels champs rÃ©cupÃ©rer.

ğŸ§ ğŸ§ ğŸ§  ClÃ´turer cette rÃ©flexion :

La premiÃ¨re mÃ©thode est la plus optimisÃ©e, mais n'est âŒ pas rÃ©alisable :

- Besoin de rÃ©cupÃ©rer les valeurs groupÃ©es par resources
  - mais la requÃªte part du compteur
  - prisma n'implÃ©mente pas encore les group by nestÃ©s (ou alors via rawQuery, mais galÃ¨re)

---

âœ…âœ…âœ… La deuxiÃ¨me mÃ©thode est plus simple & intuitive, car plus d'Ã©tapes (mÃªme si + de requÃªtes donc moins opti)

1. PremiÃ¨re requÃªte: rÃ©cupÃ©ration du compteur, donc des etapes, donc des params, donc des champs customs `RF.id & RF.name`
2. DeuxiÃ¨me requÃªte de rÃ©cupÃ©ration des (ids des) resources
   1. On en profite pour faire remonter les valeurs associÃ©es, ğŸ“œ historisÃ©es


âš¡ï¸ A noter que quelque part c'est peut Ãªtre plus optimisÃ© Ã©galement :

- Nombre de relations
  - âŒ MÃ©thode 1 :
    - compteur > steps > (calcgroup/conditions) > Params > ResourceFields > ResourceNbrVal (âš—ï¸ resourceIds)
    - Extraire les infos
    - â™»ï¸ Grouper par resources
  - ---
  - âœ… MÃ©thode 2
    - compteur > steps > (calcgroup/conditions) > Params > ResourceFields
    - resources > ResourceNbrVal (âš—ï¸ resourceFieldId)
      - âœ¨ DÃ©jÃ  extrait & groupÃ©

ğŸ‘· Egalement plus facilement:

- Controlable
- ComprÃ©hensible
- SÃ©parations des donnÃ©es CPT & Resources

---
---
---

## ğŸ’¥ Note importante : ne pas utiliser take: 1 dans la premiÃ¨re requete, mais distinct

Dans la mesure ou l'on souhaite rÃ©cupÃ©rer plusieurs valeurs historisÃ©es simultanÃ©ment.

Par exemple si je souhaite rÃ©cupÃ©rer plusieurs valeurs historisÃ©es depuis ResourceNbrVals, en passant par les Resources

RequÃªte de rÃ©cupÃ©ration de la premiÃ¨re valeur avant la pÃ©riode

```js
{
  select: partialQuerySelectResourceNbrVal, // ğŸ”ğŸ“ğŸ—ƒï¸ğŸ”¢
  // ğŸ“œâ¬†ï¸ Order by effect date ğŸš¨ DESC
  orderBy: [
    {
      effectDate: 'desc',
    },
  ],
  // * âš—ï¸ Only ResourceFields presents in this counter
  where: {
    resourceFieldId: {
      // in: [
      //   // * ğŸ“ŒğŸª¨ Gather results, hard coded, for verification
      //   '00000000-0000-0000-0000-000000000048', // employmentRatePercent
      // ],
      in: resourceFieldsIds,
    },

    // ğŸ“œ
    effectDate: { lte: period.dateStart },
  },
  // * ğŸ“œ Only the first one
  // take: 1, // ğŸ’¥ğŸ’¥ğŸ’¥
  distinct: ['resourceFieldId'], // âœ…âœ…âœ…
} as PrismaClient.ResourceNbrValFindFirstArgs;
```

Car si dans mes champs custom j'ai:

- employementRatePercent
- ET unAutre

Seul employementRatePercent remonte avec `take: 1`

Avec distinct `idRELATION` & orderBy > effectDate: 'desc' on est good, peut importe le nombre de champs.

---

### ğŸ‘· Exemples de requÃªtes

`src/ct-counters/functions/partial-query/histo`
