# üìú Gestion de l'historique & effectDate

NOTE POUR PLUS TARD : Prendre en compte les dates de fin, si 2 p√©riodes ---111---rieng---222---

- üîé Mots cl√©s recherche globale
  - effectDate effect date history historiques p√©riode avant

---

(NDM: Probl√®me lors du d√©roul√© afin de g√©n√©r√©er les instances de Schedules √† partir des CycleOnResources, qui ont une effectDate)
(Donc HS si plusieurs cycles & plusieurs dates d'effets)

---

üêõüêõüêõ Probl√®me `effectDate` 

- On ne r√©cup√®re pas "les CycleOnResource pour cette p√©riode"
- On doit r√©cup√©rer "le premier (plus proche) CycleOnResource ant√©rieur √† la date de d√©part, et les √©ventuels autres suivant avant la date de fin"
- Et pas ceux d'apr√®s !

ex:

```js
resourcesSchedulesInstancesByPeriod(
  resource: {matricule: "max"}
  period: {dateStart: "2024-04-01", dateEnd: "2024-05-30"}
)
// Ok renvoie
//      cycle.effectDate = "2024-04-01"
//      cycle.effectDate = "2024-04-15"

resourcesSchedulesInstancesByPeriod(
  resource: {matricule: "max"}
  period: {dateStart: "2024-04-03", dateEnd: "2024-05-30"}
)
// üí© KO renvoie
//      ~~cycle.effectDate = "2024-04-01"~~ Manquant
//      cycle.effectDate = "2024-04-15"
```

üêõüêõüêõ Yeah actuellement c'est pire que √ßa

```js
whereQuery.cycleOnResources = {
  some: {
    effectDate: {
      gte: period['dateStart'],
      lte: period['dateEnd'],
    },
  },
};
```

"Je renvoie les cycleOnResources des Resources dont **au moins l'une des cycleOnResources.effectDate se trouve dans la p√©riode**".

- ‚ú®ü§èüêõ Tite p√©touille > les Sch√©dules en dehors de la p√©riode sont pris en compte
  - ‚ú® Yeah c'est "normal", on renvoie l'int√©gralit√© si au moins une correspond

Besoin de revoir le where date............

Voir double requ√™te, une pour la premi√®re r√©cup√©ration, une pour la deuxi√®me....

    Nah, utilisation de `OR` (!= AND) dans prisma

D'o√π le ü§Æ besoin de gestion de effectDate, donc en dehors de l'estimation, yay fun *indeed*

---

Merci moi du pass√© pour ses d√©tails pour le probl√®me

üöÄ BREF

## üß† Algo go go

Voir les diff√©rents cas de figure pour **effectDate vs Period**, et √† mon avis y'en a des cartons

Yeah besoin de d√©finir une table des v√©rit√©s

- üë∂üë∂ UNE seule date (period) vs UNE effectDate
- üë∂ une periode vs UNE effectDate
- UNE seule date (period) vs plusieurs effectDate
- ü§Æ une periode vs plusieurs effectDate

---

temps ‚è±Ô∏è pass√© ----------------- pr√©sent ------------------------ futur

---

### üë∂üë∂ UNE date (period) vs UNE effectDate

3 possibilit√©s

- effectDate avant date
- effectDate = date
- effectDate apr√®s date

MAIS on parle de date d'effet qui court dans le temps ~= tant qu'elle n'est pas chang√©e sa valeur reste la m√™me

effectDate **avant** date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© -----XXXXXXXXXXXXXXXXXXXXXXX...----------- futur
                    ^ effectDate

‚úÖ La valeur est disponible

---

effectDate **=** date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© -----------------XXXXXXXXXXXXXXXXX...----- futur
                                ^ effectDate

‚úÖ La valeur est disponible

---

effectDate **apr√®s** date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© ------------------------XXXXXXXXXXXX...--- futur
                                       ^ effectDate

‚ùå La valeur n'est pas disponible pour cette Date

---
---
---

### üë∂ Une periode vs UNE effectDate

- periode.dateStart
- periode.dateEnd

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur

---

5 possibilit√©s

- ‚úÖ effectDate avant dateStart
- ‚úÖ effectDate = dateStart
- ü§è effectDate apr√®s dateStart & avant dateEnd
- ü§è effectDate = dateEnd
- ‚ùå effectDate apr√®s dateEnd

---

effectDate **avant dateStart**

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© ------YYYYYYYYYYYYYYYYYYYYYYYYYYYYYY...---- futur

‚úÖ La valeur est disponible sur l'ensemble de la p√©riode

---

effectDate **= dateStart**

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© -------------YYYYYYYYYYYYYYYYYYYYYYY...---- futur

‚úÖ La valeur est disponible sur l'ensemble de la p√©riode

---

effectDate **apr√®s dateStart & avant dateEnd**

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© -------------------YYYYYYYYYYYYYYYYY...---- futur

ü§è La valeur est disponible sur une partie de la p√©riode : [ effectDate > period.dateEnd ]

---

effectDate **= dateEnd**

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© ----------------------------YYYYYYYY...---- futur

ü§è La valeur est disponible sur une partie de la p√©riode : period.dateEnd (1 journ√©e)

---

effectDate **apr√®s dateEnd**

                                v P√©riode
temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© -------------------------------YYYYYY...--- futur

‚ùå La valeur n'est pas disponible pour la p√©riode : period.dateEnd (1 journ√©e)

---
---
---

### UNE seule date (period) vs plusieurs effectDate

Mwep, en fonction du nombre d'effectDate c'compliqu√©.

- A l'instinct je mettrais 2 effectDate (n & n+1) dans chaque tranche de possibilit√©, mais c'probablement moins avec les optimisations
  - Et encore pas si pire vu qu'il n'y a qu'une date & pas d'intervalles

- N1 date d'effet 1
- N2 date d'effet 2
- N3 date d'effet 3

(bof) possibilit√©s

- ‚úÖ L'une des effectDates = Date
- ‚úÖ Toutes les effectDates avant Date
- ‚úÖ effectDates avant & apr√®s Date
- ‚ùå Toutes les effectDates apr√®s Date

---

L'une des effectDates = Date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© -----N1111111111-N2222222222-N333333....-- futur

~ Peu importe si autres dates avant apr√®s, ‚úÖ La valeur est disponible pour la date d'effet qui correspond

---

Toutes les effectDates avant Date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© --N11111-N222222-N3333333333....---------- futur

‚úÖ La valeur est disponible pour la date d'effet ant√©rieure ou √©gale la plus proche

- ~Peu ou prou ce que j'avais impl√©ment√© pour lastName sous le capot de m√©moire :
- ~= Renvoyer
  - les effectDate <= Date
  - tri√©es par ordre descendant (plus r√©cente en premier)
  - seulement une
- ‚ôªÔ∏è a voir si √ßa marche partout pour une seule date

---

effectDates avant & apr√®s Date

                                v date
temps ‚è±Ô∏è pass√© -----------------X------------------------ futur
temps ‚è±Ô∏è pass√© -------N11111-N222222-N3333333333....----- futur

‚úÖ La valeur est disponible pour la date d'effet ant√©rieure ou √©gale la plus proche

---

Toutes les effectDates apr√®s Date

                     v date
temps ‚è±Ô∏è pass√© ------X-------------------------- futur
temps ‚è±Ô∏è pass√© -----------N111-N222-N333...----- futur

‚ùå La valeur n'est pas disponible pour cette Date

---
---
---

### ü§Æ Une periode vs plusieurs effectDate

ü§Æ Possibilit√©s

(Virer les cas simples en premier)

- 1Ô∏è‚É£ Une seule valeur sur l'ensemble de la p√©riode
- üî¢ Plusieurs valeurs sur l'ensemble de la p√©riode, r√©parties dans des intervalles

- ‚úÖ effectDateS avant p√©riode
- ‚ùå effectDateS apr√®s p√©riode
- ‚úÖ effectDateS avant ET apr√®s p√©riode
- ‚úÖ1Ô∏è‚É£üî¢ effectDateS avant ET pendant p√©riode
  - ~~pendant = p√©riode.dateStart // Probablement r√©sultat identique √† autre chose~~
    - ‚ôªÔ∏è Yeah nan on amalgame avec les "dates Avant"
  - pendant = milieu p√©riode
  - ~~pendant = p√©riode.dateEnd~~
    - ‚ôªÔ∏è On amalgame avec les "dates milieu", au final cela retourne une valeur valable sur une "p√©riode" de 1 jour
- ü§è1Ô∏è‚É£üî¢ effectDateS pendant (period.startDate exclue) ET apr√®s p√©riode 
- ü§è1Ô∏è‚É£üî¢ effectDateS pendant p√©riode
- ‚úÖ1Ô∏è‚É£üî¢ effectDateS avant ET pendant ET apr√®s p√©riode

---

#### effectDateS avant p√©riode

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© --N111-N22-N3333333333333333333333...------ futur

‚úÖ1Ô∏è‚É£ La valeur est disponible pour la p√©riode compl√®te, valeur unique, effectDate ant√©rieure **ou √©gale** la plus proche

---

#### effectDateS avant p√©riode

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]------------------------- futur
temps ‚è±Ô∏è pass√© ---------------------------------N111-N22-N33...------ futur

‚ùå La valeur n'est pas disponible pour cette P√©riode

---

####  effectDateS avant ET apr√®s p√©riode

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© --N111-N22-N3333333333333333333-N4444...--- futur

‚úÖ1Ô∏è‚É£ La valeur est disponible pour la p√©riode compl√®te, valeur unique, effectDate ant√©rieure **ou √©gale** la plus proche

---

#### effectDateS avant ET pendant p√©riode

Pendant : 3 possibilit√©s : periode.dateStart, milieu, periode.dateEnd

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© --N111-N2222-N3333333333333333333...------- futur

- ‚úÖ1Ô∏è‚É£ = periode.dateStart : La valeur est disponible pour la p√©riode compl√®te, valeur unique, effectDate **√©gale** la plus proche

---

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© --N111-N22-N3333333-N44444444444...-------- futur

- ‚úÖüî¢ Les valeurs sont disponibles pour la p√©riode compl√®te
  - Valeur ~N3 disponible sur [ period.dateStart > N44444.dateStart - 1 ]
  - Valeur ~N4 disponible sur [ N44444.dateStart > period.dateEnd ]

---

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© --N111-N22-N333-N444-N55-N666666...-------- futur

- ‚úÖüî¢ Les valeurs sont disponibles pour la p√©riode compl√®te
  - Valeur ~N disponible sur    [ period.dateStart  > N+1.dateEnd - 1 ]
  - Valeur ~N+1 disponible sur  [ N+1.dateEnd       > N+2.dateEnd - 1 ]
  - Valeur ~N+2 disponible sur  [ N+2.dateEnd       > N+3.dateEnd - 1 ]
  - Valeur ~N+3 disponible sur  [ N+3.dateEnd       > period.dateEnd  ]

periode.dateEnd > ‚ôªÔ∏è On amalgame avec les "dates milieu", au final cela retourne une valeur valable sur une "p√©riode" de 1 jour

---

####  effectDateS pendant (period.startDate exclue) ET apr√®s p√©riode

temps ‚è±Ô∏è pass√© -----[XXXXXXXXXXXXXX]------------------------ futur
temps ‚è±Ô∏è pass√© -----------N11111111111-N2222-N33333..------- futur

ü§è1Ô∏è‚É£ La valeur est disponible sur une partie de la p√©riode : [ effectDate > period.dateEnd ]

---

temps ‚è±Ô∏è pass√© -----[XXXXXXXXXXXXXX]------------------------ futur
temps ‚è±Ô∏è pass√© -----------N1111-N2222-N33333..-------------- futur

ü§èüî¢ Les valeurs sont disponibles pour une partie de la p√©riode : [ premi√®re effectDate > period.dateEnd ]

---

M√™me bail que avant & pendant pour plus + de effectDate sur la p√©riode

---

#### ü§è1Ô∏è‚É£üî¢ effectDateS pendant p√©riode

M√™me bail que #### effectDateS pendant (period.startDate exclue) ET apr√®s p√©riode

---

#### ‚úÖ1Ô∏è‚É£üî¢ effectDateS avant ET pendant ET apr√®s p√©riode

M√™me bail que #### effectDateS avant ET pendant p√©riode

---
---
---

üß† Clairement ce qui en ressort c'est que l'ensemble des cas ou la **date d'effet est apr√®s**:

- Une seule date d'effet > ‚ùå Pas de r√©sultat pour cette date / p√©riode
- Plusieurs dates d'effet > ‚ùå Pas de r√©sultat pour cette date / p√©riode
- Plusieurs dates d'effet dont **certaines sont apr√®s** > ‚ùå Aucun impact sur les r√©sultats

- A contrario, comme les dates courent dans le temps tant qu'elles ne sont pas modifi√©es,
la derni√®re AVANT period.dateEnd sera toujours la m√™me √† period.dateEnd
  - *‚¨ÜÔ∏è Bien entendu si les dates sont ordonn√©es*
  - ‚ôªÔ∏è‚ôªÔ∏è‚ôªÔ∏è Mayyy du coup la date juste avant celle la c'pareil, et celle d'avant aussi
    - p√©riodes d'effet
      - [period.dateEnd > n]  // N
      - [n-1 > n]             // N-1
      - [n-2 > n-1]           // N-2
      - [n-3 > n-2]           // N-3
      - ...
      - (~peu importe period.dateStart d√©pass√©e, la valeur sera celle de la derni√®re date d'effet √† d√©passer dans le pass√©)
      - [n-X > period.dateStart] // N-X
      - [n-XX > n-X]

‚ôªÔ∏èüîÄ En vrai cela marche dans les deux sens (en partant de pass√© vers futur ou futur vers pass√© mais quelques diff√©rences algo)

- üß† pass√© vers futur : pas besoin de la derni√®re date APRES la p√©riode
  - mais besoin de la premi√®re date avant
- üß† futur vers pass√© : BESOIN de la premi√®re date APRES la p√©riode
  - mais pas besoin de la premi√®re date avant
  - üß† peu ou prou √©quivalent mais c√¥t√© donn√©es r√©elles on aura plus souvent les donn√©es pass√©es

---

- ‚ôªÔ∏è a voir si cet algo √ßa marche partout pour ~~une seule date~~ la pr√©mi√®re date ant√©rieure (avec une ou plusieurs effectDates)
- ~= Renvoyer
  - les effectDate <= Date
  - tri√©es par ordre descendant (plus r√©cente en premier)
  - seulement une

---

üë∂ Apr√®s j'allais dire "de toutes mani√®res on doit r√©cup√©rer l'ensemble des couples valeur/date d'effet et refaire un d√©roul√©"

üë∂üë∂ Mais non, on peut d√©l√©guer cette partie la ailleurs (boucle lors de l'utilisation)

Virtuellement au niveau des retours attendus on peut sur-simplifier l'algo :

- Renvoyer l'ensemble des COUPLES effectDate/Value pour la p√©riode
- Renvoyer le couple ant√©rieur le plus proche √† cette p√©riode

... Et c'est tout

---
---
---
---
---
---
---
---
---

OU PAS, fin de la journ√©e, besoin d'impl√©menter & solution alternative

üî®ü§Æ yeah apr√®s pratico pratique comment je balance tout √ßa en place pour les instances de schedule ?

Actuellement r√©cup√©ration des resources[CoR] > `resourcesCycleOnResourceByPeriodQuery`

- `where`
  - Une clause pour les resources > matricule/lastname/pop
  - Une clause pour la p√©riode, mayyy a la va-vite
    - üîó Resource <> CycleOnResource [1 - n]
    - ~cycleOnResources
      - some (!= none/every)
        - effectDate
          - >= period.dateStart
          - <= period.dateEnd

~Renvoie TOUTES les Resources dont AU MOINS un des CoR se situe dans la p√©riode
~~ A noter que cela renvoie l'int√©gralit√© des CoR de chacune des Resource

Donc il faudrait plut√¥t une sous requ√™te, ou de mani√®re optimis√©e ~prisma/gql

D√©caler l'un des conditions du where > Rajouter un where dans cycleOnResources, duh

- üë∂ V√©rifier pour Max quels CoR remontent, en fonction des dates
  - Actuellement `period: {dateStart: "2024-04-01", dateEnd: "2024-04-17"}`
    - Je devrais avoir 2 cycles
    - J'ai "bien" les 4 affect√©s √† max, peut importe les dates

Le truc relou c'est pour "la premi√®re avant la date" mais si on en a avant dans la p√©riode... Ptet avec un COUNT combien y'en a dans la p√©riode, & r√©cup√©rer tout `< period.dateEnd`, LIMIT COUNT + 1

Chaque chose en son temps

- üë∂ ~~Rajouter~~ D√©placer un where dans cycleOnResources
  - ‚ú® ~whereResource => pareil
  - ‚ú® ~whereCycleOnResources => [effectDate >= period.dateStart && <= period.dateEnd]
  - ‚úÖüìå Yeah je r√©cup√®re bien que les deux concern√©es
  - ‚úÖüìå Algo g√©n√©ration instances Sch√©dules pour le dernier cycle trait√© jusqu'√† la fin de period.dateEnd
    - De m√©moire c'√©tait d√©j√† trait√©
      - La P√©riode demand√©e commence le 01/04/2024 // dateEnd: "2024-04-17"
      - periodDaysCount / Cette p√©riode comprend 17 jours dont il faut g√©n√©rer les Schedules
      - Le Cycle 'CYCLE_JOURNEE' commence le 01/04/2024 et g√©n√®rera des Schedules pour les 14 jours suivants.
      - ‚úÖüìå Le Cycle 'CYCLE_2X8' commence le 15/04/2024 et g√©n√®rera des Schedules pour les 2 jours suivants.

DONC la le souci c'est si jamais un cycle existe AVANT period.dateStart de l'inclure

- üë∑üêõ Ex probl√®me actuel:
  - si je demande la period: {dateStart: "2024-04-03", dateEnd: "2024-04-17"}
  - Cycles Max
    - Cycle 1 effectDate 2024-04-01
    - Cycle 2 effectDate 2024-04-15
  - Le cycle 1 ne sera pas r√©cup√©r√© vu que en dehors de [04-03 - 04-17]

üß† Compl√©ment de requ√™te "simple" afin de le rajouter ?

- ~üí© Pas de period.dateStart pour les CoR > ~‚úÖ Ok
  - ‚úÖ Pas de date d'effet avant > Rieng, pas de cycle attribu√©
  - ‚úÖ Une seule date d'effet avant > On la r√©cup√®re
  - üí© Plusieurs dates d'effet avant > R√©cup√©r√©es en int√©gralit√©
- üí© Requ√™te r√©cup√©rer la premi√®re ant√©rieure √† period.dateStart & mixer avec l'autre requ√™te
  - ~ effectDate < ~~= (compris dans l'autre)~~ period.dateStart & order by & ~~LIMIT~~ take: 1
  - üí© Pas s√ªr que l'on puisse `orderBy` directement dans le where
    - üí© doc
    - üí© test
  - üí© count & filtrer ou r√©utiliser en tant que variable ~`take: count + 1`
  - Merge avec `OR`

Yeah dans tous les cas il faut une deuxi√®me requ√™te

- Eviter une requ√™te par resource
  - ~R√©cup√©rer l'ensemble des premi√®res effectDate par resource
  - PUIS ~ `OR effectDate IN [resource1FirstEffectDate, resource2FirstEffectDate, resource3FirstEffectDate]`
  - & compter sur la relation pour ne garder que la bonne pour chaque resource

---
---
---

ü§Æ Yeah apr√®s c'est ni intuitif ni trop compr√©hensible ni trop maintenable

ptet plus repartir de CycleOnResource

- Rajouter une fonction qui renvoie les (id des) CoR pour des resources/p√©riode
  - Une requ√™te premi√®re effectDate
  - Une deuxi√®me toutes celles dans l'intervalle
  - Merge `.map > push`
  - Renvoyer

Pas √ºber optimis√© mais la pas trop le choix j'ai plus d'id√©es

---

### ~~CycleOnResource > fonction renvoyer par resources sur une p√©riode incl. celle d'avant~~

### üìú CycleOnResource > fonction renvoyer par resources le premier d'avant

Resources en Args > On passe par le service Resources

---

C'con parce que la premi√®re solution serait √©l√©gante pour une resource

Moins ouf pour plein.

Go tenter √ßa sera plus simple + on peut le traiter en tant que requ√™te partielle

- ~resourcesCycleOnResourceFirstHistoryBefore
- ‚úÖ service basique
- ‚úÖ resolver basique
- ‚úÖ Requete CoR basique
- ‚úÖ Requete rajouter Resource
- ‚úÖ Requete rajouter Date
- ‚úÖüìå Tester avec max
  - ‚úÖ Si pas de correspondance > renvoit un tableau vide
- ‚úÖüìå Tester avec population
- ‚úÖ GQL retours

- ‚úÖ R√©cup√©ration dans `resourcesCycleOnResourceByPeriodQuery`
- ‚úÖ Extraction des Ids Cor
  - ‚úÖüìå Max
  - ‚úÖüìå Pop
    - ‚úÖ Gestion du cas ou pas d'ids ~= pas de Cor assign√© avant cette date pour cette resource
- ‚úÖ Test avec resourcesCycleOnResourceByPeriodQuery
  - ‚úÖüìå Max
  - ‚úÖüìå Pop

Yeah pas s√ªr √† 100% pour les performances sur de la masse mayyyyyyyyyyyyyyy

Clairement:

1. Ca fonctionne
2. Facile √† impl√©menter
   1. R√©cup√©rer valeur de effectDate √† la date d'avant
   2. Ajouter aux valeurs periodStart > effectDate > periodEnd
   3. Possibilit√© d'en faire des requ√™tes partielles* & limiter les appels √† la BDD
      1. * Une requ√™te suppl√©mentaire n√©cessaire pour r√©cup√©rer les valeurs d'avant
3. Maintenance tranquilou IMO

---
---
---
---

cf.:

- `cronexia-gta/app/src/resources/resources.service.ts` > resourcesCycleOnResourceFirstHistoryBefore()
- `cronexia-gta/app/src/resources/resources.service.ts` > resourcesCycleOnResourceByPeriodQuery() > "// * üìúüåòüìÅüîó CoR History Management"

---

## 25/07/2024 > Lint & impl√©mentation globale

Algo actuellement en place

1. ~On r√©cup√®re pour l'ensemble des resources
  - La premi√®re valeur ant√©rieure ou √©gale a la date de d√©but de p√©riode (la plus proche du d√©but)
  - Si elle existe
  - (on peut les r√©cup√©rer en une fois m√™me si plusieurs resources, tant que la valeur est en relation 1-n avec la resource)
2. Ensuite, on r√©cup√®re l'int√©gralit√© des valeurs par resource, sur cette p√©riode
   1. auxquelles on ajoute les premi√®res valeurs
      1. üë®‚Äçüíª Premi√®re requ√™te on r√©cup√®re les ids uniquement, deuxi√®me on fait un `in` afin de les rajouter aux r√©sultats, m√™me si en dehors de la p√©riode
   2. ‚¨ÜÔ∏è puis on les ordonne par date
      1. üë®‚Äçüíª Attention, order est en dehors du where
   3. üë®‚Äçüíª En vrai c'est en deux √©tapes :
      1. Craft de la query
      2. Execution

Clairement c'est plut√¥t tr√®s bien optimis√© & peu ou prou fonctionnel

üí• ou prou.

---

### Le probl√®me

Dans cet algo l'un des cas de figure n'est pas g√©r√© : l'absence de valeur entre deux entr√©es

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© -------N111-N2222-RIENG-N33333333...------- futur
algo actuel     -------------N222222222-N333---------------
                                  üí•üí•

En tant que tel pour des valeurs simples ce n'est pas dramatique, on rajouter une valeur nulle avec date d'effet.

temps ‚è±Ô∏è pass√© -------------[XXXXXXXXXXXXXX]-------------- futur
temps ‚è±Ô∏è pass√© -------N111-N2222-NULLLL-N33333333...------- futur
algo actuel     -------------N222-NULLLL-N333---------------

Et c'est good.

TOUTEFOIS

üí•++ Le gros soucis vient du fait que certaines relations sont historis√©es

- üë®‚Äçüíª Pas les [n-m] implicites, vu qu'aucune valeur suppl√©mentaire n'est stock√©e
- üë®‚Äçüíª [n-m] explicites, disposant de `effectDate`

üîç Inventorier : prisma schema > effectDate

- Valeur
  - CycleBolVal
  - CycleNbrVal
  - ResourceBolVal
  - ResourceDatVal
  - ResourceNbrVal
  - ResourceStrVal
  - ScheduleBolVal
  - ScheduleNbrVal
- Relation
  - BadgeOnResource
    - effectDateStart
    - effectDateEnd // hmmmmmmmm üèãÔ∏è chiant √† g√©rer, beaucoup plus de v√©rifications
  - CycleOnResource
  - EventGroupOnResource
  - ResourceEnumVal // üìÅüìöüóÉÔ∏è Lien entre les ENUMs, leurs valeurs et les Ressources
    - Ptet probl√©matique √©galement
      - Nope c'est good
  - üîÆ Groupes Compteurs

---

### Solutions

#### ‚úÖ‚úÖ Relation > valeur nulle dans l'un des deux ids

1. Valeurs nulles > Impossible avec la relation ?
   1. La relation est la OU
   2. üí© Absence de relation √† `effectDate`
      1. üí© Si pas de relation, pas d'effectDate
   3. ü§î mw√© ou alors
      1. Si on fait sauter l'un des c√¥t√© de la relation ?
         1. ‚úÖüìå Pas s√ªr que cela passe techniquement

‚úÖ BadgeOnResource
  resourceId & ~~badgeId~~

üë∑ Max 01/04 badgeId 111
üë∑ Max 15/04 badgeId null
üë∑ Max 18/04 badgeId 222

mw√©√©√©√©√©, √† voir si faisable avec toutes les relations

---
---
---

üìåüìåüìå Pas s√ªr que cela passe techniquement
model BadgeOnResource {
  badge   Badge‚úÖ?  @relation(fields: [badgeId], references: [idBadge])
  badgeId String‚úÖ? @db.Uuid

Test avec une paire de seeds en plus

```js
// ‚úÖ
const badgeOnResource_Max_pas_de_badge_en_avril_2024 =
await prisma.badgeOnResource.upsert({
  where: { idBadgeOnResource: '00000000-0000-0000-0b05-000000000666' },
  update: {},
  create: {
    idBadgeOnResource: '00000000-0000-0000-0b05-000000000666',
    // ! üí• Attention, cela ne fonctionne QUE si aucune des relations n'est d√©finie via connect
    badgeId: null,
    resourceId: resource1.idResource,

    // * ‚úÖüîÄ Alternative : Resource connect & absence de d√©finition pour l'autre !

    effectDateStart: new Date('2023-04-01'),
  },
});

const badgeOnResource_Max_autre_badge_en_mai_2024 =
await prisma.badgeOnResource.upsert({
  where: { idBadgeOnResource: '00000000-0000-0000-0b05-000000000667' },
  update: {},
  create: {
    idBadgeOnResource: '00000000-0000-0000-0b05-000000000667',
    badgeId: badge_PO.idBadge,
    resourceId: resource1.idResource,
    effectDateStart: new Date('2023-04-01'),
  },
});
```

---
---
---

‚úÖ CycleOnResource
  resourceId & ~~cycleId~~

---

ü§î EventGroupOnResource
  eventGroupId & ???

Resource <n-m üí© implicite> EventGroupOnResource <1-n> EventGroup

Yeah leur relation est stock√©e dans `_EventGroupOnResourceToResource` g√©r√©e par Prisma

Au pire > on passe la relation en explicite sans champ suppl√©mentaire, ce qui permettrait de

_EventGroupOnResourceToResource
  ~~eventGroupId~~ & resourceId

Mais √ßa reste tordu car effectDate & la valeur nulle seraient dans des tables diff√©rentes

[prisma relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations)

D'apr√®s la doc pas obligatoire.

‚úÖ‚úÖ‚úÖ Solution

Passer la relation implicite en explicite, d√©finir l'un des champs comme optionnels

üö®üå± Attention les de la d√©finition des seeds:

- üîçüêõ `Erreur Argument 'XXX' must not be null`.
- Si l'un est null et l'autre connect, c'est üí© KO
- Soit les deux d√©finis via les XXXId
- Soit l'un d√©finit en connect et l'autre non d√©finit

```js
// üë∑ Exemples
const badgeOnResource_Max_pas_de_badge_en_avril_2024 =
  await prisma.badgeOnResource.upsert({
    where: { idBadgeOnResource: '00000000-0000-0000-0b05-000000000666' },
    update: {},
    create: {
      idBadgeOnResource: '00000000-0000-0000-0b05-000000000666',
      // üí© badge: connect: null
      // üí© badge: null             // Pas au linter mais a la compil : must no be null
      // ---
      // üí© KO, must not be null car Id & connect
      badgeId: null,
      resource: connect: { matricule: resource1.matricule },
      // ---
      // ‚úÖ les deux XXXId, OK
      badgeId: null,
      resourceId: resource1.idResource,
      // ---
      // ‚úÖ connect & absence de d√©finition de badge, OK
      resource: connect: { matricule: resource1.matricule },
    },
  });
```

---
---
---
---
---
---
---
---
---

‚úÖ ResourceEnumVal
  ~~resourceEnumId~~
  ~~resourceEnumNbrValId~~    // osef des valeurs ou null les deux pour explicite
  ~~resourceEnumStrValId~~    // osef des valeurs ou null les deux pour explicite
  resourceId

Resource <n-1> ResourceEnumVals <1-n> ResourceEnum          <n-m> resourceEnumNbrVal
                                                            \<n-m> resourceEnumStrVal
                               \<1-n> resourceEnumNbrVal
                               \<1-n> resourceEnumStrVal                   

---
---
---

#### ‚ùå Boolean affect√©

Une case en plus dans la structure

- isAffected vrai/faux
  - si faux > absence de valeur
- Rajoute un test mais pas si pire
- ‚úÖ Stock√© au niveau d'effectDate > plus transparent
- Potentiellement des mauvaises donn√©es
  - isAffected > false
  - üí© XXXId > 34567890
  - Mais bon si g√©r√© par CRUD aucun souci
    - ~~Mais vecteur √† erreur humaine~~ > dans les seeds > ca va

---
---
---

#### ‚ùå effectDateEnd

- effectDateStart
- effectDateEnd // hmmmmmmmm üèãÔ∏è chiant √† g√©rer, beaucoup plus de v√©rifications

IMO vraiment pas optimis√©

---
---
---

### ‚úÖ‚úÖ Choix de la solution

Clairement relation nulle c'est le plus simple √† mettre en place m√™me s'il y a un peu de retouche BDD (obligatoires > optionnels)

Surtout niveau logique √ßa respecte le m√™me principe qu'avec les valeurs "simples" historis√©es

yeah go

---
---
---

## üë∑ Ajout d'une description

Afin de lever les doutes & d√©saffectation "implicites" via null

model > `description String @default("üìú Ajout/R√©-affectation/Suppression d'une Resource au groupe d'Events, √† date historis√©e")`

seed > description: `üìú Ajout d'un Badge √† Max, √† date historis√©e du 01/12/2023`,
                                                                                üö® c/c avec virgule
