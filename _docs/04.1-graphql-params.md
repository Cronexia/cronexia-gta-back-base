# ðŸŒðŸ’¬ GraphQL / Params

Difference between @ArgsType & @InputType

Les deux sont utilisÃ©s afin de fournir des arguments dans GraphQL

@ArgsType > multiples, scalars uniquement, ~chiant Ã  utiliser dans GraphQL (Verbeux)

@InputType > dÃ©finition d'un objet "complexe" composÃ© de plusieurs scalars
Passage d'un seul paramÃ¨tre dans GraphQL, moins verbeux

---

cf. `cronexia-suivi/suivi/2024/01-janvier/240131-suivi.md`

---

// ðŸ’¥ðŸ’¥ðŸ’¥ `@InputType()` fields NEEDS at least one Decorator (other than `@Field`) to appear, else they are whitelisted

`@ArgsType()` aussi

---

[doc](https://notiz.dev/blog/graphql-code-first-with-nestjs-7)

@nestjs/graphql provides all decorators to generate our schema. Here are a few decorators and there usage:

@ObjectType() > generate class as [Type](https://graphql.org/learn/schema/#type-system)
@Field()      > generate a class property as a [Field](https://graphql.org/learn/schema/#object-types-and-fields)
@InputType()  > generate class as [Input](https://graphql.org/learn/schema/#input-types)
@Args         > generate method params as [Arguments](https://graphql.org/learn/schema/#arguments)
@Query()      > generate method as Query
@Mutation()   > generate method as Mutation
@ResolveField > resolve relationship property





---

### ðŸš¨ðŸ§  Note confusion

ATTENTION !

Dans la doc [NestJs > Resolvers](https://docs.nestjs.com/graphql/resolvers#object-types)

- Le schÃ©ma GraphQL est dÃ©fini depuis le **MODEL** `authors/models/author.model.ts`
  - .                   v Type de retour
  - `@ObjectType()`
  - `@Resolver(of => Author)`
  - `export class AuthorsResolver {`
- Lorsque l'on passe par le gÃ©nÃ©rateur Nest CRUD > GraphQL Code first
  - `import { GraphqlVanillaGenerated } from './entities/graphql-vanilla-generated.entity';`
  - `@Resolver(() => GraphqlVanillaGenerated)`
  - Le type de retour est dÃ©fini depuis l'**entitÃ©** !
    - Mais `@ObjectType()` Ã©galement !?
  - (schÃ©ma depuis **prisma.schema**)

ðŸ” "nestjs difference between model and entity"

~~Bon au moins je suis pas le seul Ã  galÃ©rer avec Ã§a xD~~

1. âœ… [Le fameux indien de la rescousse](https://www.youtube.com/watch?v=MKowHmVWqAc)

- DTO > Data Transfer Object
- Model > Data Transfer Object
- Entity > Data Transfer Object

D'ou la confusion.

ok kool, TOUTEFOIS

1. Entity > **Database** > ConcrÃ¨tement, les champs dans la base de donnÃ©es
   1. ðŸ‘· Exemple: Id, Prenom, Nom, Date de naissance
2. Model > (Business logic) **Back**, Les **services** > Les champs exposÃ©s depuis le back
   1. Il peuvent Ãªtre transformÃ©s, agglomÃ©rÃ©s, etc.
   2. ðŸ‘· Exemple: Id, Prenom, Nom, *Nom complet* (Prenom + " " + Nom), *Age*
   3. ðŸ›‘ Validation MAY Ã  partir du DTO ?
3. DTO > (Web) **Front**
   1. Champs accessibles depuis le front (exposition)
      1. â¬‡ï¸â¬†ï¸ COmprend Ã©galement la validation des donnÃ©es envoyÃ©es (~=`POST`)
   2. Une sÃ©lection des champs disponibles en back
   3. ðŸ‘· Exemple : Id, *Nom complet*, *Age*
   4. ðŸ›‘ Comprend la validation > `class-transformer` > ~= `@IsString()` / `@IsNumber()` / etc.

ðŸ§  OOOOOOOOkkkkkkkkkkkkkkkkkkkaaaaaaaaayyyyyyyyyyyyyy
