# üîóüêØüíéüõíüåê Relations implementations

üè≠üè≠üè≠ Process mise en place d'une relation entre deux tables (one to many) üè≠üè≠üè≠

---
---
---
---
---

## En deux √©tapes (enfin on refait 2 fois le üè≠üè≠process)

On √©tablit la relation d'un c√¥t√© (one to many), puis de l'autre (many to one).

- üö® Attention: Faire attention dans le resolver de quel c√¥t√© on se situe (cl√© √©trang√®re dispo ou non)
- üö® Attention: Pas mal de diff√©rences subtiles minuscule (instance) Majuscule (classe) / singulier_ (un) pluriel (plusieurs > tableau)
- üö® Attention: Comment les tables sont reli√©es dans le Resolver > ResolveField ? Par cl√© primaire, autre (findAll) ?

üìù cf. `cronexia-suivi/suivi/2024/02-fevrier/240202-suivi.md`

Cela permet de taper dedans des deux c√¥t√©s, et ce de mani√®re r√©cursive gr√¢ce √† `@ResolveField`

```gql
StructureResource vers R√©ference
{
  structureResources {
    name
    reference {
      name
      type
    }
  }
}

R√©ference vers StructureResource
{
  referenceById(id: 1) {
    name
    structureResources {
      value
    }
  }
}
```

---
---
---

## Pour ce composant, quelles sont les relations √† impl√©menter ?

üíéüíæ Check in `schema.prisma` relationships for the class.

**Main** module implements **Foreign** module field; usually a foreign key

‚ôªÔ∏è Then do the same thing for Foreign module, no foreignId need if it's a one to many relationship, only `@ResolveField()`

---

‚ö°Ô∏èüè≠üåê Some content already done in boilerplate, ready to copy/paste > `cronexia-gta/__boilerplate_cc_gql/`

---

## All commits names

- COMMIT_NAME: "üêØüíæüåêMOD: Relation XXX > YYY > Entity"
- COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY > Model"
- COMMIT_NAME: "üêØMOD: Relation XXX > YYY > Module"
- COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY > DTO create"
- COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY > DTO create many"
- COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY > Resolver"
- COMMIT_NAME: "üåêüìåMOD: Relation XXX > YYY > Doc*"
- > * (& Tests) > Tests will be updated after all relations are implemented
- COMMIT_NAME: "üåêüìåMOD: Relations XXX > Doc & Tests"
- COMMIT_NAME: "üåêüìåMOD: All Tests > Update XXX Queries"


## üêØüíæüåê Entity

Main module, add foreign key

```ts
// entities/main.entity.ts

  // * üîó Relations
  //      Virtual field, not present in database
  // foreign   Main @relation(fields: [foreign], references: [idMain])

  // Only the scalar, present in database, as a foreign key
  @Field(() => Int, {
    description: 'Foreign key to Foreign',
    nullable: true,
  })
  foreignId?: number;

  //      Virtual field, not present in database
  // foreign Foreign[]
```

COMMIT_NAME: "üêØüíæüåêMOD: Relation XXX > YYY > Entity"
COMMIT_NAME: "üêØüíæüåêMOD: Relation XXX > YYY [ ] > Entity"

---
---
---

## üêØüåê Model

Add the relations to the model

- COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY > Model"
- COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY [ ] > Model"

---
---
---

## üêØ Modules

~~Export foreign module service~~ // done in Boilerplate by default

```ts
// foreign.module.ts
@Module({
  exports: [ForeignService],
})
```

---

üö® Import foreign module (without circular dependancy)

```ts
// main.module.ts
import { ForeignModule } from '../foreign/foreign.module';

@Module({
  imports: [PrismaModule, ForeignModule],
})
```

‚úÖ‚úÖ‚úÖ If circular dependancy, use `forwardRef()`

```ts
// main.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ForeignModule } from '../foreign/foreign.module';

@Module({
  imports: [PrismaModule, forwardRef(() => ForeignModule)],
})
```

COMMIT_NAME: "üêØMOD: Relation XXX > YYY > Module"
COMMIT_NAME: "üêØMOD: Relation XXX > YYY [ ] > Module"

---

## üêØüå± dto/create-input

Add the possibility to edit foreign key field

// üí•üí•üí• `@InputType()` fields NEEDS at least one Decorator (other than `@Field`) to appear, else they are whitelisted

COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY > DTO create"
COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY [ ] > DTO create"

COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY > DTO create many"
COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY [ ] > DTO create many"

COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY > Foreign nested input"
COMMIT_NAME: "üêØüå±MOD: Relation XXX > YYY [ ] > Foreign nested input"

---

## üêØüåê Main Resolver

Import `@ResolveField()` stuff

```ts
// main.module.ts
import {
  ResolveField,
  Parent,
} from '@nestjs/graphql';
```

Prisma Client > Import generated types from foreign class

```ts
// main.module.ts
import {
  Main,
  Foreign,
  Prisma as PrismaClient,
} from '@prisma/client';
```

üë∑ If it isn't found, don't forget to (re)generate Prisma Client  > `bun prisma generate`

---

Import Entity & Service from foreign Class

```ts
// main.module.ts
import { ForeignEntity } from '../foreigns/entities/foreign.entity';
import { ForeignsService } from '../foreigns/foreigns.service';
```

Instanciate foreign service

```ts
// main.module.ts
export class MainResolver {
  constructor(
    private readonly mainService: MainService,
    private readonly foreignService: ForeignService,
  ) {}
```

Implement `@ResolveField()` & update üë∑üìåüìåüìå tests to reflect relationship

- MANY TO ONE : Possess foreign key
- ONE TO MANY : Virtual array in entity `// foreign[]`

```ts
  // ! ---

  // ! Field resolver functions ~= jointures
  // ! RELATION MANY TO ONE / Return only one üì¶
  @ResolveField('RELATION_LOWC_FIRST', () => RELATION_MAJ_FIRSTEntity)
  async getRELATION_MAJ_FIRST(
    @Parent() CLASSNAME_LOWC_FIRST: CLASSNAME_MAJ_FIRSTEntity,
  ): Promise<RELATION_MAJ_FIRST | null> {
    // Extraction de la cl√© √©trang√®re
    const { RELATION_LOWC_FIRSTId } = CLASSNAME_LOWC_FIRST;

  // No reference associated to this structure
  if (RELATION_LOWC_FIRSTId === null) return null;

    // Appel de la m√©thode du service de la ressource concern√©e
    //    Besoin de passer le service concern√© dans le constructeur
    return this.RELATION_LOWC_FIRSTService.findOneById(RELATION_LOWC_FIRSTId);
  }
  // * üìå Test in GraphiQL
  // {
  //   CLASSNAME_LOWC_FIRSTById(id: 16) {
  //     name
  //     RELATION_LOWC_FIRSTs {
  //       value
  //     }
  //   }
  // }

  // ! RELATION ONE TO MANY / Return [0-N] üì¶üì¶üì¶
  @ResolveField('RELATION_LOWC_FIRSTs', () => [RELATION_MAJ_FIRSTEntity])
  async getRELATION_MAJ_FIRSTs(
    @Parent() CLASSNAME_LOWC_FIRST: CLASSNAME_MAJ_FIRSTEntity,
  ): Promise<RELATION_MAJ_FIRST[]> {
    // Extraction de la cl√© √©trang√®re
    const { RELATION_LOWC_FIRSTId } = CLASSNAME_LOWC_FIRST;

    // Appel de la m√©thode du service de la ressource concern√©e
    //    Besoin de passer le service concern√© dans le constructeur
    return this.RELATION_LOWC_FIRSTsService.findByFieldName({
      fieldname: RELATION_LOWC_FIRSTId,
    });
  }
  // * üìå Test in GraphiQL
  // {
  //   CLASSNAME_LOWC_FIRSTById(id: 16) {
  //     name
  //     RELATION_LOWC_FIRSTs {
  //       value
  //     }
  //   }
  // }
```

COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY > Resolver"
COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY [ ] > Resolver"

---

// One to many only
COMMIT_NAME: "üêØüåêMOD: Relation XXX > YYY > Resolver > create*"
> * Convert idYYY to id for create > connect to foreign

---

COMMIT_NAME: "üåêüìåMOD: Relation XXX > YYY > Doc*"
COMMIT_NAME: "üåêüìåMOD: Relation XXX > YYY [ ] > Doc*"
> * (& Tests) > Tests will be updated after all relations are implemented

---
---
---

COMMIT_NAME: "üåêüìåMOD: Relations XXX > Doc & Tests"

COMMIT_NAME: "üåêüìåMOD: All Tests > Update XXX Queries"

---
---
---
---
---

## Autres notes

Attention aux relations > schema.prisma d√©finit des champs qui n'apparaissent pas en BDD (uniquement pour Prisma Client)

- üí• NE PAS les d√©finir dans les entit√©
- Entit√© > d√©finir les cl√©s √©trang√®res pr√©sentes en BDD par contre !
- Deux possibilit√© pour utiliser les jointures
  - ‚úÖ Via `@ResolveField` qui permet l'injection nest√©e directement depuis le Resolver
    - C'est transparent
    - C'est document√© via le passage de l'entit√©
  - üå± Directement dans les services, via l'attribut `where` des m√©thodes mises √† disposition par Prisma Client
    - Utilisation de `include` ou `select`

---
---
---
---
---

## Many to Many relationships

PC doc:

- [Many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations)
- [Modeling and querying many-to-many relations](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations)

Peu ou prou la m√™me chose que 1-n, avec des subtilit√©s.

Peut √™tre implicite (table interm√©diaire g√©r√©e automatiquement) ou explicite (table d√©finie & possibilit√© de champs suppl√©mentaires)

Exemple avec tout :

- Implicite : Calendar <> CalendarDay, table de liaison g√©n√©r√©e auto _CalendarToCalendarDay
- Explicite : Schedule <> ScheduleShiftType, table de liaison ScheduleShiftDetail

---

### üíæ Prisma schema

```prisma
// * Implicite
model Calendar {
  // [...]
  calendarDays      CalendarDay[]
}
model CalendarDay {
  calendars     Calendar[]
}

// * Explicite
model Schedule {
  scheduleShiftDetails      ScheduleShiftDetail[]
}
model ScheduleShiftType {
  scheduleShiftDetails      ScheduleShiftDetail[]
}
// Table jointure
model ScheduleShiftDetail {
  // Unique Id crafted through 2 foreign keys constraint
  // üõë A same shift can be assigned multiple times to a schedule
  // @@id([scheduleId, scheduleShiftTypeId])

  idScheduleShiftDetail     String                @id @db.Uuid @default(uuid())
  
  // üîó Jointure
  schedule                  Schedule              @relation(fields: [scheduleId], references: [idSchedule])
  scheduleId                String                @db.Uuid
  scheduleShiftType         ScheduleShiftType     @relation(fields: [scheduleShiftTypeId], references: [idScheduleShiftType])
  scheduleShiftTypeId       String                @db.Uuid

  // ---

  // Champs suppl√©mentaires
  hourStart           DateTime      @db.Time(0)
  hourEnd             DateTime      @db.Time(0)

  eventIfPresence     String?
  eventIfAbsence      String?
}
```

---

### üå± Seeds

Vu qu'on √† acc√®s √† tout PC, on r√©utilise, par exemple create > nested create ou connect

```ts
// Cr√©ation du premier jour
const calendarDayOne = await prisma.calendarDay.upsert({
  where: { code: 'CALENDAR_DAY_ONE' },
  update: {},
  create: {
    idCalendarDay: '98fafa3a-dd3c-40a4-b959-cd84f57a005b',
    code: 'CALENDAR_DAY_ONE',
    labelShort: 'CalendarDay one',
    labelLong: 'The first calendarDay',
    date: new Date('2023-12-24'),
    dayName: 'Jeudi',
  },
});

// Cr√©ation du premier calendrier
const calendarOne = await prisma.calendar.upsert({
  where: { code: 'CALENDAR_ONE' },
  update: {},
  create: {
    idCalendar: '17cd5de7-aef7-4f29-961f-beb502ea8ef5',
    code: 'CALENDAR_ONE',
    labelShort: 'Calendar one',
    labelLong: 'The first calendar',

    // Association nest√©e (connect), sur un champ unique
    calendarDays: {
      connect: { code: calendarDayOne.code },
    },
  },
});
```

---

### üåê DTOs

R√©utilisation du c√¥t√© Many to one classique, mais des deux c√¥t√©s

---

### üêØ Resolver & @ResolveField

Idem, r√©utilisation de PC ; par exemple utilisation du service du parent afin de r√©cup√©rer les enfants joins, via `include`.

```ts
// ! üîó Relations, nested fields

// * Calendars / Many to Many / Return [0-N] üì¶üì¶üì¶
@ResolveField('calendars', () => [CalendarModel])
async calendars(
  @Parent() calendarDay: CalendarDayEntity,
): Promise<Calendar[]> {
  // * Do not overload if already defined (include/filters in the service)
  if (calendarDay.hasOwnProperty('calendars')) {
    return calendarDay['calendars'];
  }

  // * If not, return all related entries (join)
  const { idCalendarDay } = calendarDay;

  // [n-m] implicit > JOIN table _CalendarToCalendarDay
  // Get all related (through where), calendars (through include), then extract & returns them, if any
  const calendarDaysWithCalendar = await this.calendarDaysService.findMany({
    where: {
      idCalendarDay: idCalendarDay,
    },
    include: {
      calendars: true, // Returns all joined calendars
    },
  });

  console.log('calendarDaysWithCalendar');
  console.log(calendarDaysWithCalendar); // is an Array of CalendarDays

  if (calendarDaysWithCalendar[0].hasOwnProperty('calendars')) {
    return calendarDaysWithCalendar[0]['calendars'] as Array<Calendar>;
  }
  return [] as Array<Calendar>;
}

// ---
// ---
// ---
// ---
// ---

// ! üè≠üè≠üè≠üè≠üè≠ BP üè≠üè≠üè≠üè≠üè≠

// CLASSNAME_MAJ_FIRST
// CLASSNAME_LOWC_FIRST

// RELATION_MAJ_FIRST
// RELATION_LOWC_FIRST

// * RELATION_MAJ_FIRSTs / Many to Many / Return [0-N] üì¶üì¶üì¶
@ResolveField('RELATION_LOWC_FIRSTs', () => [RELATION_MAJ_FIRSTModel])
async RELATION_LOWC_FIRSTs(
  @Parent() CLASSNAME_LOWC_FIRST: CLASSNAME_MAJ_FIRSTEntity,
): Promise<RELATION_MAJ_FIRST[]> {
  // * Do not overload if already defined (include/filters in the service)
  if (CLASSNAME_LOWC_FIRST.hasOwnProperty('RELATION_LOWC_FIRSTs')) {
    return CLASSNAME_LOWC_FIRST['RELATION_LOWC_FIRSTs'];
  }

  // * If not, return all related entries (join)
  const { idCLASSNAME_MAJ_FIRST } = CLASSNAME_LOWC_FIRST;

  // [n-m] implicit > JOIN table _RELATION_MAJ_FIRSTToCLASSNAME_MAJ_FIRST
  // Get all related (through where), RELATION_LOWC_FIRST (through include), then extract & returns them, if any
  const CLASSNAME_LOWC_FIRSTsWithRELATION_MAJ_FIRST = await this.CLASSNAME_LOWC_FIRSTsService.findMany({
    where: {
      idCLASSNAME_MAJ_FIRST: idCLASSNAME_MAJ_FIRST,
    },
    include: {
      RELATION_LOWC_FIRSTs: true, // Returns all joined RELATION_LOWC_FIRST
    },
  });

  console.log('CLASSNAME_LOWC_FIRSTsWithRELATION_MAJ_FIRST');
  console.log(CLASSNAME_LOWC_FIRSTsWithRELATION_MAJ_FIRST); // is an Array of CLASSNAME_MAJ_FIRSTs

  if (CLASSNAME_LOWC_FIRSTsWithRELATION_MAJ_FIRST[0].hasOwnProperty('RELATION_LOWC_FIRSTs')) {
    return CLASSNAME_LOWC_FIRSTsWithRELATION_MAJ_FIRST[0]['RELATION_LOWC_FIRSTs'] as Array<RELATION_MAJ_FIRST>;
  }
  return [] as Array<RELATION_MAJ_FIRST>;
}



```
